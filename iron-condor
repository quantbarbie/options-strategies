import requests
import pandas as pd
import numpy as np
from datetime import datetime, timedelta, timezone
from dataclasses import dataclass
import matplotlib.pyplot as plt
from scipy.stats import norm
from enum import Enum
import warnings
warnings.filterwarnings('ignore')
import json
import math
import time
import os
import re

BASE_URL = "https://history.deribit.com/api/v2/public/get_last_trades_by_currency_and_time"

@dataclass
class Leg:
    instrument: str
    strike: float
    option_type: str
    side: str
    delta: float
    gamma: float
    vega: float
    theta: float
    price: float
    iv: float
    crr_delta: float = None
    crr_gamma: float = None
    crr_vega: float = None
    crr_theta: float = None

@dataclass
class Position:
    entry_time: datetime
    expiry_time: datetime
    legs: list
    entry_premium: float

class OptionType(Enum):
    CALL = "C"
    PUT = "P"

class Greeks:
    r = 0.04 # fed fund rate
    @staticmethod
    def _d1_d2(S, K, T, r, sigma):
        if T <= 0 or sigma <= 0:
            sign = np.sign(S - K)
            inf = np.inf * sign
            return inf, inf

        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
        d2 = d1 - sigma * np.sqrt(T)
        return d1, d2

    @staticmethod
    def bs_delta(S, K, T, r, sigma, option_type):
        d1, _ = Greeks._d1_d2(S, K, T, r, sigma)
        if option_type == OptionType.CALL:
            return norm.cdf(d1)  
        else:
            return norm.cdf(d1) - 1.0  

    @staticmethod
    def bs_gamma(S, K, T, r, sigma):
        d1, _ = Greeks._d1_d2(S, K, T, r, sigma)
        return norm.pdf(d1) / (S * sigma * np.sqrt(T))

    @staticmethod
    def bs_vega(S, K, T, r, sigma):
        d1, _ = Greeks._d1_d2(S, K, T, r, sigma)
        return S * norm.pdf(d1) * np.sqrt(T)

    @staticmethod
    def bs_theta(S, K, T, r, sigma, option_type):
        d1, d2 = Greeks._d1_d2(S, K, T, r, sigma)
        first = - (S * norm.pdf(d1) * sigma) / (2 * np.sqrt(T))

        if option_type == OptionType.CALL:
            second = - r * K * np.exp(-r * T) * norm.cdf(d2)
            return first + second
        else:
            second = r * K * np.exp(-r * T) * norm.cdf(-d2)
            return first + second

    @staticmethod
    def crr_euro_call(S, K, r, T, sigma, n):
        dt = T / n 
        u = np.exp(sigma * np.sqrt(dt)) 
        d = 1 / u 
        p = (np.exp(r * dt) - d) / (u - d)

        ST = S * (u ** np.arange(n, -1, -1)) * (d ** np.arange(0, n + 1, 1))
        payoff = np.maximum(ST - K, 0)

        for j in range(n - 1, -1, -1):
            payoff = np.exp(-r * dt) * (p * payoff[:-1] + (1 - p) * payoff[1:]) 

        return payoff[0]

    @staticmethod
    def crr_euro_put(S, K, r, T, sigma, n):
        dt = T / n  
        u = np.exp(sigma * np.sqrt(dt)) 
        d = 1 / u
        p = (np.exp(r * dt) - d) / (u - d)

        ST = S * (u ** np.arange(n, -1, -1)) * (d ** np.arange(0, n + 1, 1)) 
        payoff = np.maximum(K - ST, 0) 
    
        for j in range(n - 1, -1, -1):
            payoff = np.exp(-r * dt) * (p * payoff[:-1] + (1 - p) * payoff[1:]) 

        return payoff[0] 

    @staticmethod
    def binomial_greeks(S, strike, r, T, vol, greek_type, option_type, n=300):
        dt = T / n
        u = np.exp(vol * np.sqrt(dt)) 
        d = 1 / u 
        p = (np.exp(r * dt) - d) / (u - d)
        dS = 0.001 * S

        if option_type == OptionType.CALL:
            binomial_tree = Greeks.crr_euro_call
        else:
            binomial_tree = Greeks.crr_euro_put

        if greek_type == 'delta':
            option_price_up = binomial_tree(S * (1 + 0.001), strike, r, T, vol, n)
            option_price_down = binomial_tree(S * (1 - 0.001), strike, r, T, vol, n)
            return (option_price_up - option_price_down) / (2 * dS)

        elif greek_type == 'gamma':
            option_price_up = binomial_tree(S * (1 + 0.001), strike, r, T, vol, n)
            option_price_down = binomial_tree(S * (1 - 0.001), strike, r, T, vol, n)
            option_price_mid = binomial_tree(S, strike, r, T, vol, n)
            return (option_price_up - 2 * option_price_mid + option_price_down) / (dS ** 2)

        elif greek_type == 'vega':
            option_price_up = binomial_tree(S, strike, r, T, vol + 0.001, n)
            option_price_down = binomial_tree(S, strike, r, T, vol - 0.001, n)
            return (option_price_up - option_price_down) / (2 * 0.001) 

        elif greek_type == 'theta':
            dT = min(0.001, T * 0.5)
            if T <= 1e-6:
                return 0.0
            option_price_up = binomial_tree(S, strike, r, T - dT, vol, n)
            option_price_down = binomial_tree(S, strike, r, T, vol, n)
            return (option_price_up - option_price_down) / dT

            
    @staticmethod
    def calculate_greeks(df: pd.DataFrame, r: float) -> pd.DataFrame:
        df['delta'] = np.nan
        df['gamma'] = np.nan
        df['vega'] = np.nan
        df['theta'] = np.nan
    
        for i, row in df.iterrows():
            S = row['spot_price'] 
            K = row['strike'] 
            sigma = row['iv'] / 100
            T = row['expiry_hrs'] / (365.25 * 24)  # tte yrs
            r = 0.04
            option_type = OptionType(row['option_type']) 
    
            df.at[i, 'delta'] = Greeks.bs_delta(S, K, T, r, sigma, option_type)
            df.at[i, 'gamma'] = Greeks.bs_gamma(S, K, T, r, sigma)
            df.at[i, 'vega'] = Greeks.bs_vega(S, K, T, r, sigma)
            df.at[i, 'theta'] = Greeks.bs_theta(S, K, T, r, sigma, option_type)
    
        return df
class DataLoader:
    def get_data(self, currency: str, start: datetime, end: datetime, dte: int, r: float = 0.04, has_csv: bool = False) -> pd.DataFrame:
        filename = f"{currency.lower()}_options_{dte}dte.csv"

        if has_csv and os.path.exists(filename):
            print(f"{filename}. Loading {filename}...")
            df = pd.read_csv(filename)
            return df

        print(f"Downloading data...")
        trades = []
        start_ts = int(start.timestamp() * 1000)
        end_ts = int(end.timestamp() * 1000)

        while start_ts < end_ts:
            params = {
                "currency": currency,
                "kind": "option",
                "start_timestamp": start_ts,
                "end_timestamp": end_ts,
                "count": 10000,
                "sorting": "asc"
            }

            response = requests.get(BASE_URL, params=params)
            data = response.json()

            if "result" not in data or not data["result"]["trades"]:
                break

            batch = data["result"]["trades"]
            trades.extend(batch)
            start_ts = batch[-1]["timestamp"] + 1

            print(f"Fetched {len(trades)} trades...")
            time.sleep(0.2)

        if not trades:
            print("No trades downloaded.")
            return pd.DataFrame()

        df = pd.DataFrame(trades)
        df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms", utc=True)

        parts = df["instrument_name"].str.split("-", expand=True)
        df["expiry"] = pd.to_datetime(parts[1], format="%d%b%y", utc=True)
        df["strike"] = parts[2].astype(float)
        df["option_type"] = parts[3]

        df["expiry_hrs"] = (df["expiry"] - df["timestamp"]).dt.total_seconds() / 3600  # in hours
        df = df[df["expiry_hrs"] >= 0] #added

        df["spot_price"] = df["index_price"]

        df = df[df["expiry_hrs"] <= dte * 24].copy() 
        
        columns_to_keep = [
            'trade_seq', 'trade_id', 'timestamp', 'tick_direction', 'price',
            'mark_price', 'iv', 'instrument_name', 'direction',
            'contracts', 'amount', 'expiry',
            'strike', 'option_type', 'expiry_hrs', 'spot_price'
        ]
        df = df[columns_to_keep]
        df = Greeks.calculate_greeks(df, r=0.04)

        print(f"[After filtering: {len(df)} trades with DTE <= {dte}.")
        
        df.to_csv(filename, index=False)
        print(f"Saved to {filename}")

        return df

    def chain_snapshot(self, df: pd.DataFrame, ts: datetime, expiry: datetime) -> pd.DataFrame:
        window = df[
            (df["timestamp"] <= ts) &
            (df["timestamp"] >= ts - timedelta(hours=1)) &
            (df["expiry"] == expiry)
        ]
    
        if window.empty:
            return pd.DataFrame()

        agg_cols = {
            "mark_price": "last",
            "iv": "last",
            "spot_price": "last",
            "timestamp": "last",
            "delta": "last",
            "gamma": "last",
            "vega": "last",
            "theta": "last"
        }
    
        chain = window.groupby(["strike", "option_type"]).agg(agg_cols).reset_index()

        chain = chain[chain["iv"] > 0]
    
        if chain.empty:
            return pd.DataFrame()

        S = chain["spot_price"].iloc[0]
        T = (expiry - ts).total_seconds() / (365.25 * 24 * 3600)
    
        chain["S"] = S
        chain["T"] = T
    
        return chain

class Strategy:
    def fit_legs(self, chain: pd.DataFrame, target_delta: float, option_type: str) -> pd.Series:
        subset = chain[chain["option_type"] == option_type].copy()
        if subset.empty:
            return None
        subset["delta_diff"] = (subset["delta"] - target_delta).abs()
        return subset.loc[subset["delta_diff"].idxmin()]

    def iron_condor(self, chain: pd.DataFrame) -> list:
        sell_call = self.fit_legs(chain, 0.20, "C")
        buy_call = self.fit_legs(chain, 0.05, "C")
        sell_put = self.fit_legs(chain, -0.20, "P")
        buy_put = self.fit_legs(chain, -0.05, "P")
        
        if any(x is None for x in [sell_call, buy_call, sell_put, buy_put]):
            return None
        
        if sell_call["strike"] >= buy_call["strike"] or sell_put["strike"] <= buy_put["strike"]:
            return None
        
        legs = [ # edited
            Leg(f"C{int(sell_call['strike'])}", sell_call["strike"], "C", "sell", sell_call["delta"], sell_call["gamma"], 
                sell_call["vega"], sell_call["theta"], sell_call["mark_price"], sell_call["iv"]),
            Leg(f"C{int(buy_call['strike'])}", buy_call["strike"], "C", "buy", buy_call["delta"], buy_call["gamma"], 
                buy_call["vega"], buy_call["theta"], buy_call["mark_price"], buy_call["iv"]),
            Leg(f"P{int(sell_put['strike'])}", sell_put["strike"], "P", "sell", sell_put["delta"], sell_put["gamma"], 
                sell_put["vega"], sell_put["theta"], sell_put["mark_price"], sell_put["iv"]),
            Leg(f"P{int(buy_put['strike'])}", buy_put["strike"], "P", "buy", buy_put["delta"], buy_put["gamma"], 
                buy_put["vega"], buy_put["theta"], buy_put["mark_price"], buy_put["iv"]),
        ]
        return legs

    def calc_premium(self, legs: list) -> float:
        return sum(leg.price if leg.side == "sell" else -leg.price for leg in legs)

    def calc_current_value(self, chain: pd.DataFrame, legs: list) -> float:
        value = 0
        for leg in legs:
            row = chain[(chain["strike"] == leg.strike) & (chain["option_type"] == leg.option_type)]
            if row.empty or pd.isna(row["mark_price"].iloc[0]):
                return None
            price = row["mark_price"].iloc[0]
            value += price if leg.side == "sell" else -price
        return value
    
    def check_delta_breach(self, chain: pd.DataFrame, legs: list, threshold: float = 0.35) -> bool:
        for leg in legs:
            if leg.side == "sell":
                row = chain[(chain["strike"] == leg.strike) &
                            (chain["option_type"] == leg.option_type)]
                if not row.empty and abs(row["delta"].iloc[0]) >= threshold:
                    return True
        return False
