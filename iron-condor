import requests
import pandas as pd
import numpy as np
from datetime import datetime, timedelta, timezone
from dataclasses import dataclass
import matplotlib.pyplot as plt
from scipy.stats import norm
from enum import Enum
import warnings
warnings.filterwarnings('ignore')
import json
import math
import time
import os
import re

BASE_URL = "https://history.deribit.com/api/v2/public/get_last_trades_by_currency_and_time"

@dataclass
class Leg:
    instrument: str
    strike: float
    option_type: str
    side: str
    delta: float
    gamma: float
    vega: float
    theta: float
    price: float
    iv: float
    crr_delta: float = None
    crr_gamma: float = None
    crr_vega: float = None
    crr_theta: float = None

@dataclass
class Position:
    entry_time: datetime
    expiry_time: datetime
    legs: list
    entry_premium: float

class OptionType(Enum):
    CALL = "C"
    PUT = "P"

class Greeks:
    r = 0.04 # fed fund rate
    @staticmethod
    def _d1_d2(S, K, T, r, sigma):
        if T <= 0 or sigma <= 0:
            sign = np.sign(S - K)
            inf = np.inf * sign
            return inf, inf

        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
        d2 = d1 - sigma * np.sqrt(T)
        return d1, d2

    @staticmethod
    def bs_delta(S, K, T, r, sigma, option_type):
        d1, _ = Greeks._d1_d2(S, K, T, r, sigma)
        if option_type == OptionType.CALL:
            return norm.cdf(d1)  
        else:
            return norm.cdf(d1) - 1.0  

    @staticmethod
    def bs_gamma(S, K, T, r, sigma):
        d1, _ = Greeks._d1_d2(S, K, T, r, sigma)
        return norm.pdf(d1) / (S * sigma * np.sqrt(T))

    @staticmethod
    def bs_vega(S, K, T, r, sigma):
        d1, _ = Greeks._d1_d2(S, K, T, r, sigma)
        return S * norm.pdf(d1) * np.sqrt(T)

    @staticmethod
    def bs_theta(S, K, T, r, sigma, option_type):
        d1, d2 = Greeks._d1_d2(S, K, T, r, sigma)
        first = - (S * norm.pdf(d1) * sigma) / (2 * np.sqrt(T))

        if option_type == OptionType.CALL:
            second = - r * K * np.exp(-r * T) * norm.cdf(d2)
            return first + second
        else:
            second = r * K * np.exp(-r * T) * norm.cdf(-d2)
            return first + second

    @staticmethod
    def crr_euro_call(S, K, r, T, sigma, n):
        dt = T / n 
        u = np.exp(sigma * np.sqrt(dt)) 
        d = 1 / u 
        p = (np.exp(r * dt) - d) / (u - d)

        ST = S * (u ** np.arange(n, -1, -1)) * (d ** np.arange(0, n + 1, 1))
        payoff = np.maximum(ST - K, 0)

        for j in range(n - 1, -1, -1):
            payoff = np.exp(-r * dt) * (p * payoff[:-1] + (1 - p) * payoff[1:]) 

        return payoff[0]

    @staticmethod
    def crr_euro_put(S, K, r, T, sigma, n):
        dt = T / n  
        u = np.exp(sigma * np.sqrt(dt)) 
        d = 1 / u
        p = (np.exp(r * dt) - d) / (u - d)

        ST = S * (u ** np.arange(n, -1, -1)) * (d ** np.arange(0, n + 1, 1)) 
        payoff = np.maximum(K - ST, 0) 
    
        for j in range(n - 1, -1, -1):
            payoff = np.exp(-r * dt) * (p * payoff[:-1] + (1 - p) * payoff[1:]) 

        return payoff[0] 

    @staticmethod
    def binomial_greeks(S, strike, r, T, vol, greek_type, option_type, n=300):
        dt = T / n
        u = np.exp(vol * np.sqrt(dt)) 
        d = 1 / u 
        p = (np.exp(r * dt) - d) / (u - d)
        dS = 0.001 * S

        if option_type == OptionType.CALL:
            binomial_tree = Greeks.crr_euro_call
        else:
            binomial_tree = Greeks.crr_euro_put

        if greek_type == 'delta':
            option_price_up = binomial_tree(S * (1 + 0.001), strike, r, T, vol, n)
            option_price_down = binomial_tree(S * (1 - 0.001), strike, r, T, vol, n)
            return (option_price_up - option_price_down) / (2 * dS)

        elif greek_type == 'gamma':
            option_price_up = binomial_tree(S * (1 + 0.001), strike, r, T, vol, n)
            option_price_down = binomial_tree(S * (1 - 0.001), strike, r, T, vol, n)
            option_price_mid = binomial_tree(S, strike, r, T, vol, n)
            return (option_price_up - 2 * option_price_mid + option_price_down) / (dS ** 2)

        elif greek_type == 'vega':
            option_price_up = binomial_tree(S, strike, r, T, vol + 0.001, n)
            option_price_down = binomial_tree(S, strike, r, T, vol - 0.001, n)
            return (option_price_up - option_price_down) / (2 * 0.001) 

        elif greek_type == 'theta':
            dT = min(0.001, T * 0.5)
            if T <= 1e-6:
                return 0.0
            option_price_up = binomial_tree(S, strike, r, T - dT, vol, n)
            option_price_down = binomial_tree(S, strike, r, T, vol, n)
            return (option_price_up - option_price_down) / dT

            
    @staticmethod
    def calculate_greeks(df: pd.DataFrame, r: float) -> pd.DataFrame:
        df['delta'] = np.nan
        df['gamma'] = np.nan
        df['vega'] = np.nan
        df['theta'] = np.nan
    
        for i, row in df.iterrows():
            S = row['spot_price'] 
            K = row['strike'] 
            sigma = row['iv'] / 100
            T = row['expiry_hrs'] / (365.25 * 24)  # tte yrs
            r = 0.04
            option_type = OptionType(row['option_type']) 
    
            df.at[i, 'delta'] = Greeks.bs_delta(S, K, T, r, sigma, option_type)
            df.at[i, 'gamma'] = Greeks.bs_gamma(S, K, T, r, sigma)
            df.at[i, 'vega'] = Greeks.bs_vega(S, K, T, r, sigma)
            df.at[i, 'theta'] = Greeks.bs_theta(S, K, T, r, sigma, option_type)
    
        return df
class DataLoader:
    def get_data(self, currency: str, start: datetime, end: datetime, dte: int, r: float = 0.04, has_csv: bool = False) -> pd.DataFrame:
        filename = f"{currency.lower()}_options_{dte}dte.csv"

        if has_csv and os.path.exists(filename):
            print(f"{filename}. Loading {filename}...")
            df = pd.read_csv(filename)
            return df

        print(f"Downloading data...")
        trades = []
        start_ts = int(start.timestamp() * 1000)
        end_ts = int(end.timestamp() * 1000)

        while start_ts < end_ts:
            params = {
                "currency": currency,
                "kind": "option",
                "start_timestamp": start_ts,
                "end_timestamp": end_ts,
                "count": 10000,
                "sorting": "asc"
            }

            response = requests.get(BASE_URL, params=params)
            data = response.json()

            if "result" not in data or not data["result"]["trades"]:
                break

            batch = data["result"]["trades"]
            trades.extend(batch)
            start_ts = batch[-1]["timestamp"] + 1

            print(f"Fetched {len(trades)} trades...")
            time.sleep(0.2)

        if not trades:
            print("No trades downloaded.")
            return pd.DataFrame()

        df = pd.DataFrame(trades)
        df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms", utc=True)

        parts = df["instrument_name"].str.split("-", expand=True)
        df["expiry"] = pd.to_datetime(parts[1], format="%d%b%y", utc=True)
        df["strike"] = parts[2].astype(float)
        df["option_type"] = parts[3]

        df["expiry_hrs"] = (df["expiry"] - df["timestamp"]).dt.total_seconds() / 3600  # in hours
        df = df[df["expiry_hrs"] >= 0] #added

        df["spot_price"] = df["index_price"]

        df = df[df["expiry_hrs"] <= dte * 24].copy() 
        
        columns_to_keep = [
            'trade_seq', 'trade_id', 'timestamp', 'tick_direction', 'price',
            'mark_price', 'iv', 'instrument_name', 'direction',
            'contracts', 'amount', 'expiry',
            'strike', 'option_type', 'expiry_hrs', 'spot_price'
        ]
        df = df[columns_to_keep]
        df = Greeks.calculate_greeks(df, r=0.04)

        print(f"[After filtering: {len(df)} trades with DTE <= {dte}.")
        
        df.to_csv(filename, index=False)
        print(f"Saved to {filename}")

        return df

    def chain_snapshot(self, df: pd.DataFrame, ts: datetime, expiry: datetime) -> pd.DataFrame:
        window = df[
            (df["timestamp"] <= ts) &
            (df["timestamp"] >= ts - timedelta(hours=1)) &
            (df["expiry"] == expiry)
        ]
    
        if window.empty:
            return pd.DataFrame()

        agg_cols = {
            "mark_price": "last",
            "iv": "last",
            "spot_price": "last",
            "timestamp": "last",
            "delta": "last",
            "gamma": "last",
            "vega": "last",
            "theta": "last"
        }
    
        chain = window.groupby(["strike", "option_type"]).agg(agg_cols).reset_index()

        chain = chain[chain["iv"] > 0]
    
        if chain.empty:
            return pd.DataFrame()

        S = chain["spot_price"].iloc[0]
        T = (expiry - ts).total_seconds() / (365.25 * 24 * 3600)
    
        chain["S"] = S
        chain["T"] = T
    
        return chain

class Strategy:
    def fit_legs(self, chain: pd.DataFrame, target_delta: float, option_type: str) -> pd.Series:
        subset = chain[chain["option_type"] == option_type].copy()
        if subset.empty:
            return None
        subset["delta_diff"] = (subset["delta"] - target_delta).abs()
        return subset.loc[subset["delta_diff"].idxmin()]

    def iron_condor(self, chain: pd.DataFrame) -> list:
        sell_call = self.fit_legs(chain, 0.20, "C")
        buy_call = self.fit_legs(chain, 0.05, "C")
        sell_put = self.fit_legs(chain, -0.20, "P")
        buy_put = self.fit_legs(chain, -0.05, "P")
        
        if any(x is None for x in [sell_call, buy_call, sell_put, buy_put]):
            return None
        
        if sell_call["strike"] >= buy_call["strike"] or sell_put["strike"] <= buy_put["strike"]:
            return None
        
        legs = [ # edited
            Leg(f"C{int(sell_call['strike'])}", sell_call["strike"], "C", "sell", sell_call["delta"], sell_call["gamma"], 
                sell_call["vega"], sell_call["theta"], sell_call["mark_price"], sell_call["iv"]),
            Leg(f"C{int(buy_call['strike'])}", buy_call["strike"], "C", "buy", buy_call["delta"], buy_call["gamma"], 
                buy_call["vega"], buy_call["theta"], buy_call["mark_price"], buy_call["iv"]),
            Leg(f"P{int(sell_put['strike'])}", sell_put["strike"], "P", "sell", sell_put["delta"], sell_put["gamma"], 
                sell_put["vega"], sell_put["theta"], sell_put["mark_price"], sell_put["iv"]),
            Leg(f"P{int(buy_put['strike'])}", buy_put["strike"], "P", "buy", buy_put["delta"], buy_put["gamma"], 
                buy_put["vega"], buy_put["theta"], buy_put["mark_price"], buy_put["iv"]),
        ]
        return legs

    def calc_premium(self, legs: list) -> float:
        return sum(leg.price if leg.side == "sell" else -leg.price for leg in legs)

    def calc_current_value(self, chain: pd.DataFrame, legs: list) -> float:
        value = 0
        for leg in legs:
            row = chain[(chain["strike"] == leg.strike) & (chain["option_type"] == leg.option_type)]
            if row.empty or pd.isna(row["mark_price"].iloc[0]):
                return None
            price = row["mark_price"].iloc[0]
            value += price if leg.side == "sell" else -price
        return value
    
    def check_delta_breach(self, chain: pd.DataFrame, legs: list, threshold: float = 0.35) -> bool:
        for leg in legs:
            if leg.side == "sell":
                row = chain[(chain["strike"] == leg.strike) &
                            (chain["option_type"] == leg.option_type)]
                if not row.empty and abs(row["delta"].iloc[0]) >= threshold:
                    return True
        return False
class Backtest:
    def __init__(self, df: pd.DataFrame, data_loader, strategy, entry_hours: int, candle_frequency: str, 
                 hours_elapsed_limit: float, profit_target_pct: float, 
                 capital: float = 1, position_size: float = 0.1):

        self.df = df
        self.data = data_loader
        self.strategy = strategy
        self.entry_hours = entry_hours
        self.candle_frequency = candle_frequency
        self.hours_elapsed_limit = hours_elapsed_limit
        self.profit_target_pct = profit_target_pct
        self.capital = capital
        self.position_size = position_size

    def backtest(self) -> pd.DataFrame:
        self.df = self.df.sort_values("timestamp")
        expiries = pd.DatetimeIndex(self.df["expiry"].unique()).sort_values()

        trades = []
        greeks_rows = []

        for expiry in expiries:
            entry_time = expiry - timedelta(hours=self.entry_hours)

            chain = self.data.chain_snapshot(self.df, entry_time, expiry)
            # print(chain.head())

            if chain.empty:
                continue

            legs = self.strategy.iron_condor(chain)

            if legs is None:
                continue
                
            try:
                S = chain["spot_price"].iloc[0]
                T = chain["T"].iloc[0]
                r = 0.04
                n = 500 
                
                for leg in legs:
                    K = leg.strike
                    sigma = leg.iv / 100.0
                    opt_type = OptionType(leg.option_type)
                
                    leg.crr_delta = Greeks.binomial_greeks(S, K, r, T, sigma, "delta", opt_type, n)
                    leg.crr_gamma = Greeks.binomial_greeks(S, K, r, T, sigma, "gamma", opt_type, n)
                    leg.crr_vega  = Greeks.binomial_greeks(S, K, r, T, sigma, "vega",  opt_type, n)
                    leg.crr_theta = Greeks.binomial_greeks(S, K, r, T, sigma, "theta", opt_type, n)

                    greeks_rows.append({
                        "entry_time": entry_time,
                        "expiry": expiry,
                        "instrument": leg.instrument,
                        "side": leg.side,
                        "strike": leg.strike,
                        "option_type": leg.option_type,
                        "iv": leg.iv,
                        "S": S,
                        "T": T,
                        "bs_delta": leg.delta,
                        "bs_gamma": leg.gamma,
                        "bs_vega":  leg.vega,
                        "bs_theta": leg.theta,
                        "crr_delta": leg.crr_delta,
                        "crr_gamma": leg.crr_gamma,
                        "crr_vega":  leg.crr_vega,
                        "crr_theta": leg.crr_theta
                    })

                    
            except Exception as e:
                print("CRR error:", e)
                continue
                
            ep = self.strategy.calc_premium(legs) 

            if ep <= 0:
                continue

            entry_premium = ep * self.position_size
            
            exit_time = None
            exit_reason = None
            exit_value = None
            last_valid_value = None 
            
            check_times = pd.date_range(entry_time, expiry, freq=self.candle_frequency)
            
            for t in check_times:
                hours_elapsed = (t - entry_time).total_seconds() / 3600
            
                snap = self.data.chain_snapshot(self.df, t, expiry)
                if snap.empty:
                    if hours_elapsed >= self.hours_elapsed_limit:
                        exit_time = t
                        exit_reason = "time_stop"
                        exit_value = last_valid_value if last_valid_value is not None else entry_premium
                        break
                    continue
            
                cv = self.strategy.calc_current_value(snap, legs)
            
                if cv is None:
                    if hours_elapsed >= self.hours_elapsed_limit:
                        exit_time = t
                        exit_reason = "time_stop"
                        exit_value = last_valid_value if last_valid_value is not None else entry_premium
                        break
                    continue
                    
                current_value = cv * self.position_size
                last_valid_value = current_value 
                pnl_pct = (entry_premium - current_value) / entry_premium
            
                if pnl_pct >= self.profit_target_pct:
                    exit_time = t
                    exit_reason = "profit_target"
                    exit_value = current_value
                    break
            
                if hours_elapsed >= self.hours_elapsed_limit:
                    exit_time = t
                    exit_reason = "time_stop"
                    exit_value = current_value
                    break
            
                if self.strategy.check_delta_breach(snap, legs):
                    exit_time = t
                    exit_reason = "delta_breach"
                    exit_value = current_value
                    break

            if exit_time is None:
                exit_time = expiry
                exit_reason = "expiry"

                snap_exp = self.data.chain_snapshot(self.df, expiry, expiry)

                if snap_exp.empty:
                    continue

                S = snap_exp["S"].iloc[0]

                exit_value = 0
                for leg in legs:
                    if leg.option_type == "C":
                        intrinsic = max(0, (S - leg.strike) / S)
                    else:
                        intrinsic = max(0, (leg.strike - S) / S) 
                    exit_value += intrinsic if leg.side == "sell" else -intrinsic

                exit_value *= self.position_size

            pnl = entry_premium - exit_value
            pnl_pct = pnl / entry_premium if entry_premium > 0 else 0

            trades.append({
                "entry_time": entry_time,
                "exit_time": exit_time,
                "expiry": expiry,
                "exit_reason": exit_reason,
                "entry_premium": entry_premium,
                "exit_value": exit_value,
                "pnl": pnl,
                "pnl_pct": pnl_pct,
                "legs": str([(l.instrument, l.side, l.price) for l in legs])
            })

        trades_df = pd.DataFrame(trades)
        greeks_df = pd.DataFrame(greeks_rows)
        
        return trades_df, greeks_df

    def calc_sharpe(self, trades_df: pd.DataFrame) -> float:
        if trades_df.empty:
            return 0.0

        df = trades_df.sort_values("exit_time")

        start = df["entry_time"].min().normalize()
        end = df["exit_time"].max().normalize()
        days = pd.date_range(start, end, freq="1D")

        capital_series = pd.Series(index=days, dtype=float)
        capital = self.capital

        trade_idx = 0
        ntrades = len(df)

        for day in days:
            while trade_idx < ntrades and df.iloc[trade_idx]["exit_time"].normalize() == day:
                capital += df.iloc[trade_idx]["pnl"]
                trade_idx += 1

            capital_series[day] = capital

        daily_returns = capital_series.pct_change().dropna()

        if daily_returns.std() == 0:
            return 0.0
        
        sharpe = ((daily_returns.mean()) / daily_returns.std()) * np.sqrt(365) 

        return sharpe

    def calc_stats(self, trades_df: pd.DataFrame) -> dict:
        if trades_df.empty:
            return {}

        df = trades_df.sort_values("exit_time")
        returns = df["pnl_pct"].values  # this is pl from each trade

        equity = self.capital + df["pnl"].cumsum()  # check that it's not (1+returns).cumprod()
        rolling_max = np.maximum.accumulate(equity)
        drawdowns = (rolling_max - equity) / rolling_max  
        max_dd = drawdowns.max()
        
        days = (df["exit_time"].max() - df["entry_time"].min()).days

        if days > 0:
            final_capital = equity.iloc[-1]
            cagr = (final_capital / self.capital)**(365 / days) - 1
        else:
            cagr = 0.0
            
        wins = df[df["pnl"] > 0]
        losses = df[df["pnl"] <= 0] 
        sharpe = self.calc_sharpe(df)  

        return equity, {
            "total_trades": len(df),
            "win_rate": len(wins) / len(df),
            "total_return": equity.iloc[-1] - self.capital,
            "annualised_return": cagr,
            "max_drawdown": max_dd,
            "avg_profit": wins["pnl"].mean() if len(wins) > 0 else 0,
            "avg_loss": losses["pnl"].mean() if len(losses) > 0 else 0,
            "sharpe_annual": sharpe,
            "exit_reasons": df["exit_reason"].value_counts().to_dict()
        }
n_dte = 3
end = datetime(2025, 11, 29, 19, 0, 0, tzinfo=timezone.utc)
start = end - timedelta(days=60)
    
data_loader = DataLoader()
df = data_loader.get_data("BTC", start, end, dte=n_dte, has_csv=False)

if df.empty:
    print("No data found")
strategy = Strategy()
backtester = Backtest(df, data_loader, strategy, entry_hours=6, candle_frequency="1min", # check freq
                        hours_elapsed_limit=4, profit_target_pct=0.25, capital=1, position_size=1) 
trades_df, greeks_df = backtester.backtest()
trades_df.to_csv("backtest_trades.csv", index=False)
greeks_df.to_csv("greeks.csv", index=False)
equity, stats = backtester.calc_stats(trades_df)
    
print("\n=== BACKTEST RESULTS ===")
print(f"Total trades: {stats['total_trades']}")
print(f"Win rate: {stats['win_rate']:.1%}")
print(f"Sharpe (annual): {stats['sharpe_annual']:.2f}")
print(f"Total return: {stats['total_return']:.1%}")
print(f"Annualised return: {stats['annualised_return']:.1%}")
print(f"Max drawdown: {stats['max_drawdown']:.1%}")
print(f"Avg profit: {stats['avg_profit']}")
print(f"Avg loss: {stats['avg_loss']}")
print(f"Exit reasons: {stats['exit_reasons']}")
trades_df['equity'] = equity
eq_df = trades_df[['exit_time', 'equity']]
eq_df.to_csv("equity_curve.csv", index=False)
print("[INFO] Saved equity curve to 'equity_curve.csv'.")

plt.figure(figsize=(10, 6))
plt.plot(eq_df['exit_time'], eq_df['equity'], label="Equity Curve", color='#A2D2FF')
plt.title("Equity Curve Over Time")
plt.xlabel("Exit Time")
plt.ylabel("Equity")
plt.grid(True)
plt.xticks(rotation=45) 
plt.tight_layout()
plt.legend()
plt.show()
